set nocompatible
filetype off

"Setting up Vundle - the vim plugin bundler
let iCanHazVundle=1
let vundle_readme=expand('~/.vim/bundle/vundle/README.md')
if !filereadable(vundle_readme)
    echo "Installing Vundle.."
    echo ""
    silent !mkdir -p ~/.vim/bundle
    silent !git clone https://github.com/gmarik/vundle ~/.vim/bundle/vundle
    let iCanHazVundle=0
endif
set rtp+=~/.vim/bundle/vundle/
set rtp+=$GOROOT/misc/vim

call vundle#rc()

Plugin 'gmarik/vundle'
Plugin 'Valloric/YouCompleteMe'
"Plugin 'pangloss/vim-javascript'
"Plugin 'adimit/prolog.vim'
"Plugin 'xolox/vim-misc'
"Plugin 'xolox/vim-session'
Plugin 'tpope/vim-fugitive'
Plugin 'tmhedberg/matchit'
Plugin 'tmhedberg/SimpylFold'
Plugin 'Lokaltog/vim-easymotion'
Plugin 'scrooloose/syntastic'
Plugin 'tpope/vim-surround'
Plugin 'MarcWeber/vim-addon-mw-utils'
Plugin 'tomtom/tlib_vim'
Plugin 'c9s/bufexplorer'
Plugin 'scrooloose/nerdtree'
Plugin 'scrooloose/nerdcommenter'
"Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
"Plugin 'tpope/vim-rails.git'
"Plugin 'vexxor/phpdoc.vim'
Plugin 'kien/ctrlp.vim'
"Plugin 'Lokaltog/vim-powerline'
"Plugin 'Lokaltog/powerline'
"Plugin 't9md/vim-ruby-xmpfilter'
Plugin 'sjl/gundo.vim'
Plugin 'rking/ag.vim'
Plugin 'majutsushi/tagbar'
Plugin 'haya14busa/incsearch.vim'
"Plugin 'fatih/vim-go'
" Ultrasnip (snippets)
Plugin 'SirVer/ultisnips'
Plugin 'honza/vim-snippets'
"Haskell Plugins
"Plugin 'dag/vim2hs'
"Plugin 'eagletmt/ghcmod-vim'
"Plugin 'Shougo/vimproc.vim'
"Plugin 'eagletmt/neco-ghc'
Plugin 'terryma/vim-multiple-cursors'
Plugin 'mtth/scratch.vim'

" Plugin to allow easy data flow b/n vim and tmux
Plugin 'benmills/vimux'

" vim-scripts repos
"Plugin 'PIV'
Plugin 'FuzzyFinder'
"Plugin 'HTML-AutoCloseTag'
"Plugin 'VimCalc'
"Plugin 'phpcomplete.vim'
"Plugin 'xml.vim'
"Plugin 'camelcasemotion'
Plugin 'L9'
"Plugin 'preview'
Plugin 'shinokada/dragvisuals.vim'
if iCanHazVundle == 0
    echo "Installing Plugins, please ignore key map error messages"
    echo ""
    :BundleInstall
endif

filetype plugin indent on     " required!

set guifont=DejaVu\ Sans\ Mono\ for\ Powerline\ 9
Bundle 'Lokaltog/powerline', {'rtp': 'powerline/bindings/vim/'}
let g:Powerline_symbols = 'fancy'
"source ~/.vim/bundle/powerline/build/lib/powerline/ext/vim/source_plugin.vim
"python from powerline.ext.vim import source_plugin; source_plugin()

syntax on
set pastetoggle=<F9>
set ssop-=options
set encoding=utf-8
set history=2707
set undolevels=2512
set colorcolumn=80
set laststatus=2
"set visualbell
set noerrorbells
set wrapscan
set nowrap
set noswapfile
"set nobackup
set backup
set backupdir=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set backupskip=/tmp/*,/private/tmp/*
set directory=~/.vim-tmp,~/.tmp,~/tmp,/var/tmp,/tmp
set writebackup
set autoindent
set copyindent
set showmatch
set ruler
set hlsearch
set wildmenu
set incsearch
set number
set tabstop=4
set shiftwidth=4
set softtabstop=4
set ignorecase
set smartcase
set smarttab
set lazyredraw
set expandtab
set modelines=0
set backspace=start,indent,eol
set t_Co=256
set showtabline=2
set noshowmode
"set guifont=Monaco:h13
set nolist  "hide invisible characters
set autowrite
"set list
"set listchars=tab:>.,trail:.,extends:#,nbsp:.
"folding settings"
"set foldmethod=indent
set foldnestmax=2
set nofoldenable
set foldlevel=1

" Folding plugin settings
"let g:SimpylFold_docstring_preview = 1
let g:SimpylFold_fold_docstring = 0
let mapleader=","       " leader is comma

" allows cursor change in tmux mode
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" theme configs
let g:solarized_termcolors=256
set background=dark
colorscheme solarized

" CtrlP settings
let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'

" easymotion configs
let g:EasyMotion_leader_key = '<Leader>'

" session configs
let g:session_autosave = 'no'

"Shortcuts
let g:UltiSnipsExpandTrigger="<C-;>"
let g:UltiSnipsJumpForwardTrigger="<C-;>"
let g:UltiSnipsJumpBackwardTrigger="<C-b>"
let g:UltiSnipsEditSplit="vertical"

" Syntastic always show the errors
let g:syntastic_auto_loc_list=1

"nerdcommenter change toggle shortcut
map ,g :call NERDComment(0,"toggle")<CR>
map <Bar> :NERDTreeToggle<CR>
nmap <F8> :TagbarToggle<CR>
"vmap <C-f> :fold<CR>
nmap <CR> :set rnu!<CR>
map <C-c> :nohlsearch<CR>
"map <C-S-l> :set rl<CR>
"map <C-S-k> :set norl<CR>
map <C-l> :tabn<CR>
map <C-h> :tabp<CR>
map <C-n> :tabnew<CR>

" binding for folding (=)
nmap = za

map s <Plug>(easymotion-s)
" make f as next page
"nnoremap f <C-f>
"nnoremap g <C-b>
" make 1 as quit without saving (do not force for thick fingers)
nnoremap - :q<CR>
" open vimrc
nnoremap <leader>vi :tabnew ~/dotfiles/vim/vimrc<CR>


" syntastic check
nnoremap <leader>l :SyntasticCheck<CR>

"command P !python %
map <C-j> :exec '!python' shellescape(@%, 1)<CR>
imap <C-j> <Esc>:exec '!python' shellescape(@%, 1)<CR>

" Python 3 
"map <C-m> :exec '!python3' shellescape(@%, 1)<CR>
"imap <C-m> <Esc>:exec '!python3' shellescape(@%, 1)<CR>
"map <leader>c :Calc<CR> 

"haya14busa incremental search
map /  <Plug>(incsearch-forward)
map ?  <Plug>(incsearch-backward)
map g/ <Plug>(incsearch-stay)


nmap <space> i_<Esc>r
"nnoremap <space> za 
"vnoremap <space> zf
"seeing is believing key bindings
"let g:xmpfilter_cmd = "seeing_is_believing"
"autocmd FileType ruby nmap <buffer> <F5> <Plug>(seeing_is_believing-run)
"autocmd FileType ruby xmap <buffer> <F5> <Plug>(seeing_is_believing-run)
"autocmd FileType ruby imap <buffer> <F5> <Plug>(seeing_is_believing-run)

cmap w!! %!sudo tee > /dev/null %

" change key bindings
nnoremap ; :
" move vertically by visual line
nnoremap j gj
nnoremap k gk
" move to beginning/end of line
nnoremap B ^
nnoremap E $
" $/^ doesn't do anything
"nnoremap $ <nop>
"nnoremap ^ <nop>
" highlight last inserted text
nnoremap gV `[v`]
nnoremap <leader>u :GundoToggle<CR>
" open ag.vim
nnoremap <leader>a :Ag

"autocmd FileType php set omnifunc=phpcomplete#CompletePHP
"autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
autocmd FileType html,xml set listchars-=tab:>.

"php configs
"au BufRead,BufNewFile *.php		set indentexpr= | set smartindent
"au BufRead,BufNewFile *.phps		set filetype=php
"au BufNewFile,BufRead *.thor set filetype=ruby
"let g:DisableAutoPHPFolding=1
"let b:match_ignorecase = 1


"ruby configs
"autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading = 1
"autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
"autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global = 1

"improve autocomplete menu color
highlight Pmenu ctermbg=gray ctermfg=black gui=bold

"Use filetype plugins, e.g. for PHP
"inoremap <C-K> <ESC> :call PhpDocSingle()<CR>
"nnoremap <C-K> :call PhpDocSingle()<CR>
"vnoremap <C-K> :call PhpDocRange()<CR>

" YCM configs
let g:ycm_auto_trigger = 1
let g:ycm_semantic_triggers = {'haskell' : ['.']}
let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_autoclose_preview_window_after_insertion = 1

" This is to fix the ValueError:  still no compile flags, no completions yet
" for the  C and CPP codes
let g:ycm_global_ycm_extra_conf = "~/dotfiles/vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py"
" If the current buffer has never been saved, it will have no name,
" call the file browser to save it, otherwise just save it.

" Code to save the file
"inoremap <leader><leader> <Esc>:w<CR>
"nnoremap <leader><leader> <Esc>:w<CR>
"map <Esc>s :w<CR>
"map <Esc><Esc> :w<CR>
"command -nargs=0 -bar Update if &modified 
                           "\|    if empty(bufname('%'))
                           "\|        browse confirm write
                           "\|    else
                           "\|        confirm write
                           "\|    endif
                           "\|endif
"nnoremap <silent> <C-q> :<C-u>Update<CR>

" Code to rename the file
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'), 'file')
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        "exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>r :call RenameFile()<cr>
let g:Powerline_symbols = 'fancy'
let g:Powerline_dividers_override = ["\Ue0b0", "\Ue0b1", "\Ue0b2", "\Ue0b3"]
let g:Powerline_symbols_override = { 'BRANCH': "\Ue0a0", 'LINE': "\Ue0a1", 'RO': "\Ue0a2" }

" settings for dragvisuals.vim
runtime plugin/dragvisuals.vim

vmap  <expr>  <LEFT>   DVB_Drag('left')                     
vmap  <expr>  <RIGHT>  DVB_Drag('right')                    
vmap  <expr>  <DOWN>   DVB_Drag('down')                     
vmap  <expr>  <UP>     DVB_Drag('up')                       
vmap  <expr>  D        DVB_Duplicate()                      

" Remove any introduced trailing whitespace after moving... 
let g:DVB_TrimWS = 1

" commenting it out.. instead switched to setinvcursorline permanently
" since i find it useful at other times too
set invcursorline
" function to highlight the next search by Damian conway
"nnoremap <silent> n   n:call HLNext(0.4)<cr>
"nnoremap <silent> N   N:call HLNext(0.4)<cr>

"function! HLNext (blinktime)
        "set invcursorline
        "redraw
        "exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
        "set invcursorline
        "redraw
"endfunction

"function! HLNext (blinktime)
        "let [bufnum, lnum, col, off] = getpos('.')
        "let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
        "let target_pat = '\c\%#\%('.@/.'\)'
        "let ring = matchadd('WhiteOnRed', target_pat, 101)
        "redraw
        "exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
        "call matchdelete(ring)
        "redraw
"endfunction


" program to open pdf files as text using pdftotext
" run pdftotext to read PDF files
" run pdftotext to read PDF files
    
fun s:readpdf()
    if (!executable("pdftotext"))
        echo "Error: pdftotext not installed or not in path"
        return
    endif

    let tmp = tempname()
    " invoke: pdftotext sourcefile.pdf tempfile
    call system ("pdftotext '" . escape (expand("<afile>"), "'") . "' " . tmp)
    setlocal nobin
    execute "silent '[-1r " . tmp
    " clean up the temporary file
    call delete(tmp)

    " make the buffer unwritable: we don't want to clobber the PDF file!
    set nowrite
endfun

autocmd BufReadPost,FileReadPost *.pdf call s:readpdf()

" Adding ability to read Man pages from vimrc
runtime! ftplugin/man.vim

" Setting the tmux pane name as vi file name
autocmd BufReadPost,FileReadPost,BufNewFile * call system("tmux rename-window ". expand("%:t"))


" Code for Vimux
function! VimuxSlime()
    call VimuxSendText(@v)
    call VimuxSendKeys("Enter")
endfunction

"let g:VimuxWidth = "35" "default is 20
let g:VimuxOrientation = 'v'
let g:VimuxUseNearest = 1

vmap <Leader>vs "vy:call VimuxSlime()<CR>
nmap <Leader>vs vip<Leader>vs<CR>
map <Leader>vv Bv$"vy:call VimuxSlime()<CR>
map <Leader>va ggVG"vy:call VimuxSlime()<CR>
map <Leader>vo :call VimuxOpenRunner()<CR>
map <Leader>vq :VimuxCloseRunner<CR>
map <Leader>vg :VimuxInspectRunner<CR>
map <Leader>vl :VimuxRunLastCommand<CR>
